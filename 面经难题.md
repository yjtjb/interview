### 1.redis的哨兵模式和集群模式分别用来解决什么问题？
哨兵模式为了解决高可用性，但对于读写没有任何增强，而集群模式是为了解决读写压力，对于缓存的数据比较大的情况下用集群。
### 2.redis的集群模式有什么限制？
不同节点上的数据无法使用事物。
### 3.线程池中的阻塞队列具体是怎么通过可重入锁实现的?
通过两个condition和ReentrantLock来实现，入队的时候检查队列是否满了，如果满了就放到full的contidion中等待唤醒，没有满就插入队列唤醒读的contidion，出队同理，如果空的就放到读的contidion
### 聊一下对AQS的理解？
AQS是一个实现锁和同步机制的框架，它的底层逻辑就是当一个线程请求资源的时候如果该资源是空闲的就把该线程变成工作线程，如果资源是锁定的，就把该线程放到队列中等待唤醒，主要是通过volatitle修饰的state来表示资源的状态，一个CHL队列来储存等待唤醒的线程。采用了模版方法的设计模式，即用户通过继承AQS类来重写模版方法，在需要AQS的组件时候，调用该模版方法就等于调用充血好的方法。
### http的报文格式有哪些？
请求行：请求的方法，urlhttp的版本哈
相应行：状态码 状态说明
请求头：key value
### 数据库mysql表示时间的类型你知道有哪些？
datetime time date
### Java 实现线程安全的方式？
1.用atomic变量
2.用volatile修饰
3.加锁例如用synchronized
4.用threadloacl
### 读写锁咋么实现？
记录 w和r的量，在contaion和mutux。
### dubbo的通信协议有哪些？
dubbo rmi http hessian redis webservices memcached
### synchronized与lock的使用场景？
 synchronized适用于并发度比较低的场景，因为他会锁升级成重量锁是无法撤回的，会浪费cpu资源，lock是可以挂起等待的，提供了阻塞的能力。
### select poll epoll
在使用的时候，首先需要把关注的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理
epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。
epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合
### spring 依赖注入
1.Spring中到底有几种依赖方式？
1.手动注入（set方法、构造方法）
2.自动注入
   1.XML自动注入（set方法、构造方法）
   2.@Autowired注解的自动注入（属性、构造方法、普通方法）
Spring在启动的时候会解析你的XML文件，解析过后发现你是通过byName/Bytype方式去自动注入的，然后就会去UserService这个类去找所有的Set方法，取Set方法的名字，付给对应属性
