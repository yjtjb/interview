### 介绍一下你做的RPC项目
模仿阿里的dubbo框架，做了一个远程方法调用的框架，框架主要分为三个部分，服务端（提供方法），客户端（进行方法调用），注册中心（负责方法地址的注册与查找），对这些部分进行分层设计主要分为以下几层：
       config层：进行RPC参数的配置主要是接口的版本号以及接口的组号，组号用来辨认一个借口有多个实现方法选择哪个方法。
       proxy层：用来生成一个对应接口的代理类，用代理类实现方法的远程调用以及结果的返回，封装复杂的网络传输的过程，只需要调用接口的方法就可以了。
       register层：用来进行服务的注册以及服务的发现和负载均衡的选择。
       remoting层：进行网络传输的封装以及具体实现。
       serialize层：序列化层，进行序列化的实现。
并且贯穿项目的是一套模仿dubbo的spi机制，通过指定名称可以获得接口的具体实现类，使得
项目的启动流程就是

### 为什么使用zookepeer不用redis做注册中心？
zookepper满足CAP中的强一致性以及分区容错性，而redis对于强一致性没有zookepeer做得好，并且数据结构有点浪费，也没有watch功能能够马上的发现节点挂了。
### 你对paxos算法的了解
基于分布式一致性的算法有三个角色
提议者：提出提案
接受者：接受提案，如果超过一半以上的人接受了，这个提案就会通过，并且让学习者执行
学习者：执行，结果返回客户端。
### zookepeer的强一致性
通过ZAB原子广播协议达成
主要是由leader follower 观察者组成
只有leader能够进行写操作，在接收到请求后会产生一个提案分配给一个全局唯一id，把提案放到一个队列中然后发送给给follower，follower接收到提案后会把事件日志写到磁盘中返回ACK，接收到一半以上的ACK可以认为提案通过，发送commit请求。

