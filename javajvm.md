### jvm的内存区域
运行时数据区域：
线程共享：方法区（1.8后变成了元空间） 堆 线程私有：虚拟机栈 本地方法栈 程序计数
程序计数器：用来显示当前线程所执行的字节码的行号指示器，通过改变这个计数器的值来选取下一条要执行的指令从而实现选择，循环，异常处理。在多线程的情况下用于记录当前线程执行的位置，在上下文切换后知道执行到哪里了。
虚拟机栈：java方法的调用都是通过栈来实现，每次方法执行都有一个方法被压入栈中，每个栈的元素有局部变量表，操作数栈（用作方法的中间栈），动态链接（用来服务一个方法中要调用其他方法，java编译后，变量和方法引用都放在class文件的常量池里，当一个方法要调用另一个方法，就把动态链接作用就是把符号引用转换成直接引用）、方法返回地址，随着方法结束就会销毁。
本地方法栈：虚拟机栈为虚拟机执行的java方法，而本地方法栈则为虚拟机使用的native方法服务。
堆：存放对象实例。也是垃圾管理的主要区域。
方法区：用来存放类信息，字段信息，方法信息，常量，静态变量，运行时常量池，字符串常量池等数据，永久代和元空间使用的直接内存
运行时常量池：在方法区里，存放编译期间生成的字面量和符号引用的常量池表。
字符串常量池：为了减少string的内存消耗开辟的区域，避免字符串的重复创建。
### 方法区和永久代的关系？
很想接口和类的关系，方法区是一个抽象的概念，而永久带或者元空间是具体实现的方法。
### 如何创建一个对象？
1.首先检查这个类有没有在常量池中有符号引用，并且这个符号引用有没有被加载解析过，如果没有就需要进行类加载。
2.要为这个对象分配内存空间有两种分配法：空闲列表，指针碰撞，指针碰撞适合堆空间连续，维护一个指针，左边分配好右边没分配，想着没用过的地方移动指针Serial、ParNew，空闲列表维护一个列表记录哪些内存使用，哪些没有使用，会找一个足够大的分配。CMS，而对于内存分配线程安全，采用CAS+重试，以及TLAB，对内存分配采用CAS进行分配如果分配失败则重试，TLAB则是会在新生代分配给线程一个空间，如果空间用完会用CAS再进行分配。
3.把这个内存地址清零，就可以不初始化也能使用
4.给这个内存地址进行对象头的编写，属于哪个类，GC参数等
5.按照程序员给的代码进行init初始化
### 对象的内存布局
对象头：储存对象自身运行时的数据和类型指针，通过类型指针确定是哪个对象的实例。
数据：信息
对齐填充：占位
### 如何对对象进行访问定位
通过句柄和直接指针
句柄：reference指向，堆里面会开辟一个句柄池，句柄会有两个指针，一个指向堆里面的到对象的实例数据，一个指向方法区的对象的类型数据。
直接指针：referen堆里面直接储存了对象的实例数据以及指向方法区的类型数据。
其中直接指针的速度更加快主要使用这种方法，句柄的修改会更加简单，因为不用修改句柄的地址，只需要修改句柄指向的数据。
### 内存分配
分为新生代和老年代，
对象首先分配在新生代中的eden中，如果eden满了会触发minor GC，同时触发空间分配担保，把中间存活的对象分配到suirvivor中，
大对象直接分配到老年代
存活久的对象分配到老年代
动态对象判定
空间分配担保
### 判断对象是否死亡的方法
引用计数法，用一次+1，引用失效-1，如果为0无法使用，会产生循环引用的情况
可达性分析：从GC root为起点开始向下搜索，走过的路径为引用链，，如果一个对象没有和任何的GCroot有引用链就要回收，
可以成为GC root的点：
虚拟机栈中引用的对象
本地方法栈引用的对象
方法区中类静态属性引用的对象
被同步锁持有的对象。
会进行两次标记，第一次会加入队列，第二次从队列中删除。
### 强引用、软引用、弱引用、虚引用
强引用属于最普通的引用，只要强引用关系在就不会被回收
软引用如果内存空间足够就不会回收
弱引用任何时候都会被回收
虚引用用来进行追踪对象的垃圾回收活动
### 判断一个常量是废弃常量
如字符串常量，没有被引用就是废弃常量
### 判断一个类是无用的类
要满足三个条件

该类的所有实例已经被回收
加载该类的calssLoader已经被回收
该类对应的class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集有哪些算法，各自的特点
标记-清除：标记出所有不需要回收的然后回收没有标记的对象，会产生大量内存碎片
标记-复制：将内存分为大小相同的两块，每次用其中的一块，一块用完了，把存活下来的对象复制到另一块中。（新生代）
标记-整理：标记完后把所有存活的往一端移动。
分代收集算法：将堆分为新生代和老年代，新生代中每次都有大量对象死去，可以采用标记复制算法，而老年代中存活比较高，而且没有额外空间进行分配担保，所以使用标记-整理或者标记清楚。
### 为什么要分新生代和老年代

### 垃圾回收器有哪些
serial收集器单线程的 新生代采用复制，老年代采用标记-整理
ParNew收集器是多线程的
CMS收集器 是多线程的并发收集器，通过标记-清楚算法实现的。
初始标记：暂停所有线程，记录下与root相连的
并发标记：同时开始GC和用户线程，记录可达对象。
重新标记：为了修正并发标记期间被修改的引用
并发消除：开启GC线程对未标记的区域进行清理。
G1收集器：会优先回收价值大的区域，用分代和标记整理回收算法。
### minorGC和FUllGC
新生代和老年代新生代，触发空间分配担保。
### 类文件的结构
class文件标志
文件版本
常量池：存放符号引用：类和方法的名，方法的名称和描述，字段的名称和描述，字和字面量，
访问标志：识别类或者接口的访问信息，比如是类还是接口，是不是public等
当前类的索引：用于确定这个类的全限定名。
子段、方法、属性表集合：
### 类加载过程
加载 验证 准备 解析 初始化
加载：通过类的全限定名定义这个类的二进制字节流，将字节流所代表的的静态储存结构转化为方法区的运行时数据结构 在内存中生成一个代表该类的class对象，作为方法区类信息的访问入口
验证：确保符合规范，文件格式验证，元数据验证，字节码验证，符号引用验证
准备：分配内存并设置类变量的初始值
解析：将常量池的符号引用转化为直接引用。
初始化：执行java代码，调用构造器
必须进行类加载，遇到new关键字
### 双亲委派模型
一个类加载器进行类加载的时候首先委派给父类加载器进行加载，层层委派上去，只有父类加载器无法加载，子加载器才会尝试自己加载。
从下到上依次是自定义加载器，应用程序加载器，拓展类加载器，启动类加载器，可以避免重复加载产生多个相同的字节码。
