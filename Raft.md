
 这个项目是基于raft论文以及mit6.824 lab框架完成的一个强一致性，高可用的分布式储存系统，做这个项目的初衷也是为了了解一些分布式的知识，另一方面提高自己的代码水平。
 接下来说一下我做了哪些实现
 首先在整个集群中用Raft做底层协议，raft的思想是把日志同步这样的共识问题分成Leader选举与日志同步两部分完成，raft节点会有三种状态leader follower 候选者，每次选举根据大部分节点的投票产生一个leader，之后leader负责对其他节点的日志同步，大多数节点投票产生的leader解决了可能存在的脑裂问题，而leader以外其他节点被动接受同步解决了冲突问题，Raft的底层结构保证了每个结点收到的日志顺序都是相通的，在上层我们做客户端和服务器端的交互，每当一台client发起请求，leader服务器接受，先把指令放在自己的日志中，到下层做同步，等大多数节点回复已经完成好了同步这个指令后做提交，并在上层执行，执行在KV储存里就是根据key值获取或者修改数据，成功后就对客户端返回结果，没成功客户端一定时间后会选择重发。
 接下来是我对原本raft算法的优化
对日志同步加速的优化，由于leader节点随时可能出现宕机、网络分割这样的问题，每个节点上的日志可能会不同或者冲突，raft最初采用保守同步，每次同步的RPC只比较一个日志记录，可以优化成每次比较一个任期的记录，一方面不会因为要比较的节点多leader每次都要发送全部的日志记录。
对选举leader节点的优化，为了使数据尽可能的不丢失，要选举数据最完善的节点当leader，所以在每次请求投票的时候，候选者节点同时会附上自己的节点长度和最后的任期，其他节点收到拉票信息后，会比较任期和节点长度，如果自己的任期大或者节点长度大就不会投票，这样就能保证最后选举出来的leader节点是数据完善的。
第二部分优化是在关键信息改变的时候将数据持久化到硬盘，这样可以加速节点的修复，持久化的数据包货当前的任期号、投票投给了谁、以及日志，持久化也保证了选举的安全性，比如不储存投票投了谁的话，节点可能在重启的时候再次投票，破坏选举大多数的规则选出错误的leader。
### 如何实现领导者的选举？
每个Raft节点都有三个状态leader follower 候选者，在每个节点初始化后，调用一个协程开启监听，当节点在规定时间内没有收到leader的心跳信号的时候，就会触发领导选举机制，raft节点会把自己的状态转化为候选者，并给自己投一票，同时也会给其他raft节点发送投票信息，其他raft节点收到投票信息后，如果自己没有投票，就会把票投给该节点并返回，之后不能给其他节点投票，当一个节点收到半数以上的票之后，他会把自己的状态改变为leader，并同时向其他节点发送心跳信号，其他节点收到心跳信号后会把自己的状态改为follower停止选举。永远原子类的方式记录投票数
### 选举超时的机制？
为了防止同时多个候选人相互拉票而导致无法选举出leader，我在每个raft节点开始选举的时候随机产生一个选举超时时间，超时后会重新发起选举，这样就不同同时超时，在下一次选举中，时间短的可以先发拉票消息。
### 关于任期的作用？
主要是让raft节点他储存的数据是不是过时了，同时也为了防止因为脑裂问题出现多个leader，任何节点如果收到了比自己大的任期的消息，他就会转化成为follower节点。
### 如何进行日志同步？
raft的leader节点维护两个变量一个是上一次同步的任期，一个是上一次同步的日志序号，在每次心跳检测中，同时也会带有日志同步检测，如果当前节点的日志任期或者日志序号小于leader的上一个同步序号直接返回false，不然就遍历当前的日志，找到冲突的节点，因为raft的底层结构，保证之前的节点日志顺序是相同的，只需要把之后的节点全部替换为leader的日志，就可以完成日志的同步。而leader节点在接受到raft节点反馈的信息后，更新自己的nextindex和matchindex，如果同步失败，则把nextindex会退-1。
### 日志同步的优化？
正常的raft算法在日志冲突的时候采用回退-1的算法，可能需要回退n次非常损耗时间，而在这个项目里，我优化了回退算法，在发生任期或者日志完全冲突的情况下，添加了两个返回数据，即冲突任期和冲突日志序号，当前节点的日志长度低于leader节点发的日志序号时，表示冲突节点就是当前节点的最后一个日志，所以直接返回当前日志节点的长度。而如果当前节点的日志的任期发生冲突时，会返回给Leader冲突的任期，而leader收到该冲突任期后，会该找到冲突任期的最后一个节点作为nextindex，再次进行同步。
### 如何保证数据的安全性？
采用选举优化的方法，和日志同步，因为大多数的原则，最后得到的节点一定是commit后提交完全的
### 持久化？
为了保证节点的修复和关键信息的储存，每当raft节点当前任期号，投票投给了谁，日志发生更改的时候都要进行一次持久化的操作，持久化当前任期是为了防止leader节点宕机产生新的leader节点后的脑裂问题，投票投给了谁为了防止多次重复投票。

