# * redis
## 为什么使用redis？
在做美食点评项目的时候遇到了瓶颈，在秒杀订单的业务中我使用Jmeter进行1秒200个线程高并发测试时数据库基本上扛不住了，这时候就需要缓存中间件来加入，现在比较常用的中间件有redis和memcached,并且redis支持更丰富的数据类型，能持久化，支持集群模式、发布订阅模型、lua极爱本、事务等功能比memcached更加适合这个项目的业务逻辑，所以最后选择了redis
## redis有哪些数据结构以及使用场景是什么？
redis基本的数据结构有 String List Hash set Zset
String 使用SDS实现，**可以储存二进制数据和文本数据**，用一个len来记录字符串长度所以获取字符串长度的时间复杂度为O(1),而C语言m没有储存数组的长度需要遍历O(n)，并且**SDS解决了缓冲区溢出的问题**，在每次凭借字符串时候会检查剩下的长度够不够，如果不够就进行自动扩容，所以不会产生溢出。字符串对象有三种内部编码，int，raw，embstr，redisobject由type，编码，ptr指针组成，如果字符串保存的是int，就会讲int转化成long放在ptr中，将编码设置为int，如果字符串比较短会使用embstr，直接分配一块连续的地址保存redisobject和sds，如果字符串比较长会使用raw编码，在内存中开辟一块新的地址保存sds，并把ptr指针指向sds。embstr的编码模式因为是分配在连续内存中的所以如果长度增加重新分配的成本会很高，所以embstr编码的字符串对象是**只读**的，如果要进行修改会把embstr变成raw再进行增加长度。
使用场景：redis是单线程的所以执行命令的过程有原子性用来进行**常规计数**（点赞数，访问，转发）、**用setNX实现分布式锁**如果key不存在返回true表示获得锁成功，如果key存在返回false获得锁失败，**共享session信息**不同的服务器单独储存session会出现重复登录等问题，用redis对session信息进行统一的储存和管理。

List由**双向链表**或**压缩列表**实现，比较小的列表用**压缩列表**，压缩列表是连续内存块组成的顺序性数据结构，表头由zlbytes占用内存字节数，zltail偏移量，zllen节点数量组成，中间就是由表节点组成，最后用zlend当作结束符255,表节点由prevlen前一个节点长度，encoding编码这个节点数据类型长度，和data数据组成，表节点会根据数据的类型和大小选择不同的空间编码分配内存空间，如果前一个节点长度小于254，prevlen用1个字节储存，大于254用5个字节，如果数据是整数用1个字节进行编码，如果是字符串根据大小用1/2/5字节的空间进行编码，压缩列表在查询表头表尾的元素只需要O(1)的时间，查询其他节点地方需要O(n)复杂度，并且在新增某个元素或者修改某个元素的时候可能会产生**连锁更新**的问题（就比如一堆253长度的节点，突然头部插入一个255长度的节点，所有节点都要更新prevlen），所以只能用于储存节点数量不多的场景。最新的redis用**listpack**代替压缩列表和压缩列表不同的是列表头只有总字节数，和元素数量，而表结点中只舍弃了prevlen，只记录当前节点长度就不会产生连锁更新的问题**双向链表**比普通的链表添加了指向链表头和链表尾的指针，并且添加了链表节点数量len，并且用指针保存节点值增加了节点值复制、释放、比较函数可以保存各种不同类型的值。双向链表**内存开销大**，并且**地址不连续**。redis5.0之后使用quicklist来进行链表的实现，quicklist可以理解为多个压缩列表的列表，每个quicklist的节点都指向一个压缩列表，如果新增数据会检查当前节点的压缩列表能不能容纳，如果不能容纳就新增一个新的节点。
使用场景：消息队列，list因为是先进先出的数据结构可以用Lpush、rpop保证消息的顺序到达，通过设计全局唯一ID并在消费者地方记录处理过的id保证不处理重复消息，并且可以用BRPOPLPUSH命令进行备份的list记录保证消息可靠性。

Hash是用健值对集合，其中比较小的hash是用**压缩列表**组成，如果比较大用**哈希表**进行实现，
