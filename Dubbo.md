### 什么是RPC？
RPC是远程服务调用，可以让计算机像调用本地方法一样，调用远程方法。
### 为什么有了http还有rpc？
http只要是用于b/s架构，而RPC更多用于C/S架构，设计起来不用考虑很多细节，性能会比较快。
### RPC的原理？
rpc主要由
服务消费端：
客户端stub：
网络传输：
服务端stub：接收到客户端的请求后执行对应方法并返回
服务提供端：
注册中心：
组成，流程是服务端向注册中心注册自己的服务，然后客户端从注册中心拿到服务相关信息，客户端就是代理类把相关的参数序列化后传送给服务端，服务端接受到数据后反序列化得到参数，服务端根据调用的方法名字，、参数调用本地的方法，再把得到的执行结果序列化后传送到客户端，客户端再反序列化该结果，方法调用完成。
### 什么是dubbo？
dubbo是阿里开源的一个高性能、轻量级的java RPC框架，主要由container服务运行容器，负责加载、运行服务，provider服务提供者向注册中心注册自己提供的服务，consumer服务消费方，想注册中心订阅自己的服务，regisrty注册中心负责服务注册与发现返回服务提供者地址列表给消费者，monitor统计服务调用测试和调用时间的监控中心组成。
### dubbo的架构
分为三大层
业务层：serive我们的业务开发逻辑
RPC层：
config配置层，初始化配置信息
proxy层；生成一个代理类，做远程调用和返回结果
regisiter：封装了服务注册与发现
cluster：路由和集群容错曾，负责选择具体调用的节点
monitor：监控层，负责监控统计调用的时间和次数
protoclol：远程调用层，封装RPC调用负责管理invoker，invokr代表对远程调用的抽象
remoting层：
Exchange：信息交换用来封装请求响应模型，同步转异步
transpot：网络传输，抽象网络传输层
序列化曾：将数据序列化成二进制也可以反序列化
### spi机制
服务发现机制，把接口和具体实现完全耦合开，就定义了一个接口，只需要在对应的路径下放置一个接口名字的文件，在文件里写入具体的实现类的名字，就可以通过配置来决定具体用哪个实现。
### java的spi实现
通过调用serviceLoader的load，对默认路径下找接口名称一样的文件进行扫描，然后可以得到实现类的全限定名，把所有的具体实现类实例化后储存在缓存中，然后从缓存中取出进行调用。会吧所有的类都实例化。 无法按需加载实现类
### dubbo的spi实现
首先配置文件用键值对存放。前面是key后面是全限名。首先通过类接口名获得对应的extensionLoader，再通过对应的loader和name获取对应的实现方法。
根据类名从缓存中找到或者新建extensionLoader，在根据loader调用getextension方法，现在缓存中找有没有对应的实现类，如果没有，则获取对应name的类的全限定名，通过反射实现该类，遍历set方法进行依赖注入，并返回。
其中获得全限定名的方法是，从三个文件下进行读取，采用key和value储存的方式，将这些key和value存入缓存中，并根据标签分类，Adaptive，包装类 和普通类，分别存入不同的缓存。
然后关于如果不想提前定义name，而想在运行的时候进行实现类的获取，就从adaptive，可以注释类和方法，注释类的自适应要自己实现，在构造方法里就通过extensionload把所有的实现类放到缓存里，然后进行查找返回。如果注释在方法上，会自动生成一个包含这些方法的代理类。
### dubbo的spi的AOP
就是包装类，一些类的具体实现方法会有一些代码重复，这时候就搞了一个包装类，对包装类的判断就是构造方法只有一个参数并且是扩展接口的类型。
### dubbo的spi的IOC
反射获得有所方法，对其中的setter方法注入依赖。
### dubbo的服务暴露
提供者首先通过proxy根据protoco协议将方法invoker，invoer在包装一下通过register注册到注册中心。
服务的暴露从spring IOC容器刷新完成后，根据配置组装成URL，根据URL参数进行本地和远程调用。通过代理工厂的getinvoker，利用javassist来进行动态代理，封装真的实现类，通过url参数选择对应的协议。第一次暴露的时候还会进行创造监听服务器，默认是Netty，包装好的exporter存到一个MAP中，方便之后的远程调用查找，最后向注册中心注册提供者的信息。
### dubbo的服务引入
有两种模式懒汉和饿汉，其中饿汉加载完毕就引入，懒汉只有这个服务被注入到其他类中使用才引入。
首先通过配置生成URL，向注册中心注册消费者的信息，并获得服务提供者的信息。
得到信息后，通过该信息生成invoker，一条配置消息就是一个invoker，再通过cluster层包装invoker，返回代理类。
### dubbo的服务调用
通过之前生成的代理类，从cluster的字典网络中通过负载均衡选取一个invoker发起调用，并附上请求id，服务端接受到请求后通过参数找到之前存在map中的exporter，在通过invoker进行调用世纪方法并返回。客户端接收到结果后，根据对应的请求ID，把结果放到对应的future中，唤醒等待的线程，服务调用完毕。

### dubbo的负载均衡
随机权重
平滑加权轮询
最小活跃数
一致性哈希
