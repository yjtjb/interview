### 数据库的三大范式
第一范式：要求每个子段都只能对应一个值
第二范式：要求每个记录可以被唯一的区分，要求有一个主键，非主属性依赖于主键
第三范式：不能有传递函数的依赖
### mysql的架构是什么样子的？
客户端通过连接器与mysql进行连接，首先在mysql缓存中查找是不是有对应的数据，如果有就返回，如果没有通过分析器进行语法分析，通过优化器进行计划生成和索引的选择，通过执行器去操作数据库引擎返回结果，数据库引擎储存数据提供读写接口。
### mysql储存引擎
mysql的储存引擎是采用插件式的架构，可以为不同的数据库配置不同的储存引擎，可以为主要分为inondb和myisam，其中现在的mysql默认innodb，其中innodb和myiasm的区别是，innodb支持行级锁而myisam只支持表级锁，innodb支持事务而myisam不支持，innodb支持redo log恢复数据库，innodb支持外建，innodb的索引文件和数据文件都是一样的myisam分开都是B+树，innodb支持MVCC。
### 什么是索引？
相当于书中的目录，就是帮助储存引擎快速搜索数据的一种数据结构。
### 索引有哪些分类？
按照数据结构分：B+tree索引、hash索引、full-text索引，其中B+树是默认索引，在创建表的时候会根据主键，不包含null的唯一建、自增id建立索引。
按照物理储存分：聚簇索引、非聚簇索引
按照字段特性分类：主键索引（唯一的，不能为空）、唯一索引、前缀索引
按照字段个数分：单列索引、联合索引（联合索引满足最左匹配原则）按照最左优先的方式进行索引的匹配，再遇到>,<,like,between就会停止匹配，索引下推获得了一个二级索引会在储存引擎对联合索引包含的字段进行判断需要的列是不是符合要求，减少回表个数。建立联合索引要把区分度大，长度比较短，使用最频繁的建放在前面。
### 什么需要建立索引
索引的好处就是提高查询速度，但是需要花费额外的空间和时间进行维护，所以我们要对那些具有很高区分度的字段，经常用于where查找的字段，以为经常用于group by和order by的字段因为在B+
树中已经排好序了，不用重新排序。而对于不经常查找，或者大量重复区分度不高的字段，比较小的表，经常更新的字段都不需要建立索引优化
### 如何做索引优化？
前缀索引优化、覆盖索引优化、主索引最好是自增的、防止索引失效
可以通过前缀索引减少索引字段大小，增加一个索引页中储存的索引值，但不能对order by以及无法使用索引覆盖
可以使用覆盖索引进行优化，就是通过建立一些联合索引的方式来直接返回数据不用进行回表操作
主健用作自增的话，我们在插入B+刷入节点的时候就可以顺序添加，不会导致移动已有的数据，如果是随机的会导致其他数据移动，并且有可能产生内存碎片导致数据不够紧凑，印象查询效率，并且索引不要有NULL值。
然后要注意索引失效的场景，
对索引使用左模糊匹配或者使用左右模糊匹配，因为B+树的索引是根据从索引值有序排序的，只能根据前缀进行比较，如果左边是模糊的话就不能用上索引了。
对索引使用函数也可能造成索引的失效
对索引进行表达式计算，因为索引只保存初始的值，并不能进行计算
对索引进行隐藏类型转换mysql在进行字符串和数字相互比较的时候，会把字符串转化为数字再进行比较，如果字符串是索引列，而比较是数字，就等于对mysql需要对索引进行函数操作，会导致索引失效。
没有遵循最左匹配，
where子句中的OR条件有一个不是索引
### innodb如何储存数据
以数据页为单位进行读写，每一页的大小为16KB，数据页按照主健的顺序组成链表，一个页目录有很多个槽位，槽位记录最大记录，用二分法定位到所在槽位，然后顺序便利槽内的所有记录。
### 为什么采用B+树作为索引？
因为B+树他只有叶子结点储存数据，其他节点储存的都是索引，这样可以大大减少树的高度，并且B+树在插入删除也更方便不会产生复杂的变化，使得读出一个数据需要的io操作次数大大减少，同时他的叶子结点是按顺序排列并且以链表的形式链接在一起，可以支持顺序查找以及范围查找。
### 什么是事务？
在mysql引擎层实现，逻辑上的一组操作，要么都执行，要么都不执行，事务具有ACID，
原子性：事务里的操作要么都执行要么都不执行
一致性：再事务开始前的总数和事务结束后的总数不变
隔离型：允许多个并发事务同时对数据进行读写和修改的能力，对于每个事务对于其他并发事务都是隔离的，不会影响到别的事物。
持久性：事务结束后对数据库的修改是永久的不会丢失
### 并发事务会引发什么问题？
脏读：事务读到了另一个事务没有提交修改的数据就会引发脏读，因为另一个事务可能会发生回滚，这样的话读到的数据就是过期的数据了
不可重复读：一个食物多次读同一个数据，如果这个数据前后不一致就会产生不可重复读的现象。
幻读：一个事务多次查询符合条件的记录数量，出现记录数量前后不一致
### 事务的隔离级别有哪些？
读未提交：可以读到其他未提交的事务
读提交：只能读到提交过后的事务（解决脏读问题）通过read view来实现，在每次语句执行的的时候产生一个read view快照。
可重复度：从事务开始的数据都事务执行读到的数据都一样（解决可重复度问题）通过read view实现，在每次事务开始的时候创建一个read view快照。
串行化：对记录加上读写锁，事务必须串性的完成对这个纪录的操作（解决幻读问题）也可以通过可重复读加上行锁和间隙锁的组合完成。
### 说说MVCC
MVCC是一种并发控制的方法，数据库的MVCC的是为了解决并发场景下的读写问题，使得读操作的时候不用阻塞写操作，写操作执行的时候不用堵塞读操作，通过read view 隐藏字段来实现，read view中有四个重要的字段分别是活跃的事务id列表，id最小的活跃事务，创建read view时给下一个事务的id以及自身的事务id，同时聚簇索引记录中包含两个隐藏列，一个用来记录自身的事务id，一个指向undo log保存了历史版本记录。在创建readview之后我们通过索引记录中的事务id进行判断，如果记录的事务id小于read view里的最小活跃事务id，表示这个记录是在创建read view之前就有的，所以这个纪录对当前事务可见。如果大于给下一个事务的id，就是不可见的。在活跃事务列表中不可见，不在可见。

### 可重复读是咋么实现的？
在事务运行的开始前就创建read view。
### 读提交是咋么工作的？
在每次执行语句的时候产生一个新的read view。
### 幻读如何解决？
通过next-key锁，也就是记录锁和间隙锁的组合。

### mysql的锁有哪些咋么实现？
全局锁，表级锁，行锁。

全局锁使用后整个数据库就处于只读状态，对数据的增删改和对表结构的修改都会被阻塞。主要数据库的备份中，但也可以采用可重复读的隔离级别在备份前创先一个read view，在备份过程中都使用这个read view，这样读到的数据都是一样的。

表级锁（针对非索引字段加的锁）
表锁，对一个表进行加锁，有两种锁一种读锁一种写锁，写锁是独占的，读锁和读锁之间可以共享，但读写锁和写写锁之间都会冲突
元数据帧，也分为MDL读锁和MDL写锁，这是为了保证进行操作的时候其他数据对表的结构进行更改。
意向锁，分为意向共享锁，和意向独占锁，对记录加上共享或者独占锁操作前要对表加上意向锁，意向锁之间不会发生冲突，只会与表锁发生冲突，因为表锁和行锁之间是会满足，读写，写写互斥的，意向锁的目的是为了快速判断表里是不是有记录被加锁了，这样如果加表锁的话就不用一行一行的去查找了。

行级锁（针对索引字段加的锁）
记录锁：把一条记录锁上
间隙锁：锁定一个范围，但是不包含记录本身
next-key锁：间隙锁和记录锁的组合，锁定一个范围并且锁定记录本身。用来防止幻读。

### mysql加锁过程
next-key锁前开后闭，间隙锁前后都开
分成几种情况
唯一索引等值查询记录存在next-key就会变成记录锁，记录不存在就是间隙锁
唯一索引范围查询，会对记录一直查询，然后对查询到的采用记录锁，对查询不到的就用间隙锁
非唯一索引等值查询，如果记录存在会限价next-key和间隙锁（遍历到第一个不符合的直后停止），不存在就还是用间隙锁。
非唯一索引范围查询，就直接时next-key锁不会退化

### 间隙锁咋么实现互斥？
A事务锁住了间隙，B事务使用插入意向锁，无法插入达到互斥。

### mysql死锁
比如A和B事务同时产生了间隙锁，并且都有插入操作，插入的直都在A和B的间隙锁内，就会循环等待。

### mySQL的日志
undo log:用于回滚和MVCC
redo log：用来数据恢复用WAL技术，有记录需要更新，会先写到redo log中，并且更新内存，然后再找个合适的时间更新到磁盘上，并且redo log的写磁盘操作是顺序写，提高了性能。undo log也要记录在redo log上
bin  log：用来主从复制和数据备份。所有引擎都可以用

### 一条SQL语句如何执行的？
首先进行mysql缓存区查询，如果缓存区有数据就进行返回，没有的话就由分析器进行语法分析，优化器进行索引选择和计划安排，再由执行器负责对储存引擎的查找，调用储存引擎的接口，这时候如果该数据直接在buffer pool中，就直接返回，如果没有就把数据页从磁盘读到buffer pool中，然后执行器查看记录更新前后的直是不是相同，如果相同就不进行更新操作，如果不同开始进行更新操作，首先修改记录undo log的redo log，再修改undo log，修改缓冲区数据所在的页，并将该页设置为脏。后续找一个合适的时机将脏页写入磁盘。更新完成后，记录对应的binlog，在事务提交完成后将binlog刷新到磁盘。

### 如何进行sql优化？
表优化
尽量使用数字，比较速度比字符串快很多
用varchar代替char减少空间占用
查询优化
避免使用select *
避免where后用or来连接条件
避免出现<>!=.
索引优化
上面讲过

### 慢查询如何优化
用explain进行分析，看是不是包含了不必要的字段、索引是不是用上了、数据量比较大考虑分表

